/***	bridge.c**	VST Mach-O Bridge****	Copyright (c) 2002 Alex Lagutin.**	<alex@subband.com>****	VST is a trademark of Steinberg Soft- und Hardware GmbH.**	VST PlugIn Interface Technology by Steinberg Soft- und Hardware GmbH.****	Feel free to use or modify this code without any restrictions whatsoever.**	However I would like to know if you found this code useful,**	you can contact me at <alex@subband.com>*//***	Description:**	VST Mach-O Bridge allows you to create VST Mac OS X plug-ins using**	Mach-O development toolchain (Project Builder, etc.)**	With these development tools it is very easy to use low-level**	Mac OS X APIs such as POSIX threads or BSD sockets in your plug-ins.****	Discussion:**	Mac OS X VST plug-ins are implemented as PowerPC code resources**	in CFM PEF object format. Apple's Project Builder development**	environment cannot create objects in this format (at least not in**	the standard distribution.)**	VST Mach-O Bridge removes this limitation by providing a "bridge"**	that loads a plug-in in Mach-O object format and translates calls**	from CFM binary interface to Mach-O binary interface and vice versa.**	The "bridge" operations are totally transparent to the host application**	and plug-in code.****	Completed plug-in using VST Mach-O Bridge is assembled from 2 pieces -**	1. Bridge code resource of type 'aEff'**	This part is implemented as ordinary VST plug-in with**	the only difference - it does nothing but loads the real plug-in code**	and translates host-to-plugin and plugin-to-host calls.**	It is stored as the resource of type 'aEff' in the resource fork of**	resulting plug-in file.**	2. Plug-in in Mach-O object format of type 'MH_BUNDLE'**	This part is created using Mach-O development toolchain (Project Builder, etc.)**	and is put as data fork into resulting plug-in file.**	Also, plug-in file should have file type 'aPcs' to be recognized by host application**	as a file containing VST plug-in code.****	Here are the step-by-step instructions for creation of such plug-in with Project Builder:**	(you should already know how to create CFM VST plug-ins)**	1. Start with Project Builder template project "Bundle".**	2. Add source files to the project.**	3. Add "vst_macho_bridge.r" file containing the bridge code to your project**	and set "Put Mac OS resources: in Resource fork of the executable" option in the**	"Linker Settings" section of the "Build Settings" pane.**	4. Change resource name of the bridge resource to the name of your plug-in**	(default name is "VST Mach-O Bridge")**	5. Rename your plug-in's main function to "vst_main"**	Note: if your code is C++, declare it as extern "C" function like this:**	extern "C" { AEffect *vst_main(audioMasterCallback audioMaster); }**	6. Compile and link plug-in's code, you will find the plug-in file in**	"YourBundleName.bundle/Contents/MacOS/" directory, named (no surprises) "YourBundleName".**	7. Set file type of plug-in file to 'aPcs'.**	Congratulations! now you have VST Plug-in compiled with Project Builder.****	Known bugs/issues**	Since there's no VSTGUI library in Mach-O object format (as far as I know)**	you cannot use it in Mach-O plug-ins.*/#pragma export onconst char copyright[] = "VST Mach-O Bridge 1.0\nCopyright (c) 2002 Alex Lagutin.\n<alex@subband.com>";#pragma export reset#include <string.h>#include <MacMemory.h>#include <Files.h>#include <Resources.h>#include <TextUtils.h>#include <CFBundle.h>#define	MAC 1/***	VST SDK license doesnt permit distribution of the VST SDK parts or whole by**	third parties, so you have to download the SDK by yourself to get this file included.**	look for the SDK somewhere at www.steinberg.se*/#include "AEffect.h"	/* part of the VST SDK */#ifdef	PATH_MAX#undef	PATH_MAX#endif#define	PATH_MAX	1024/* CFM trampoline to the vst_main function of the Mach-O object */static AEffect *(*vst_main)(audioMasterCallback audioMaster)	= NULL;/* private instance data */#pragma options align=powertypedef struct TVec{	void	*addr;	void	*rtoc;} TVec;typedef struct priv_data{	TVec	pre_dispatcher;	struct	{		void	*dispatcher;		void	*process;		void	*setParameter;		void	*getParameter;		void	*processReplacing;		void	*audioMaster;	} tramp;} priv_data;#pragma options align=reset/***	get_vst_main()****	loads Mach-O object in the data fork and returns CFM trampoline**	to the vst_main function of it****	Expects:**	a. current resource file reference number points to ourselves**	b. data fork of current file is Mach-O object of type 'MH_BUNDLE'**	with defined global symbol "vst_main"*/static void *get_vst_main(void);/* CFM to Mach-O/Mach-O to CFM trampolines */static void *MachOForCFM(void *cfmfp);static void *CFMForMachO(void *machofp);/***	__terminate() will be called at CloseConnection() time****	:TODO:**	implement module unlinking since host will no longer use our code**	Dont forget to add check to NOT UNLINK modules with Obj-C code otherwise**	host application will crash*/void __terminate(void){}/***	we use this dispatcher pre-process routine to catch effClose messages**	and dispose all the extra memory we alloc'ed*/static long fx_dispatcher(AEffect *effect, long opCode, long index, long value,						void *ptr, float opt){	priv_data	*data = (priv_data *) effect->dispatcher;	int			result;	long		(*_dispatcher)(AEffect *effect, long opCode, long index, long value,						void *ptr, float opt) = data->tramp.dispatcher;		/* call the real dispatcher */	result	= _dispatcher(effect, opCode, index, value, ptr, opt);		if (opCode == effClose)	{		/* deallocate the extra memory we used */		if (data->tramp.dispatcher)			DisposePtr((char *) data->tramp.dispatcher);		if (data->tramp.process)			DisposePtr((char *) data->tramp.process);		if (data->tramp.setParameter)			DisposePtr((char *) data->tramp.setParameter);		if (data->tramp.getParameter)			DisposePtr((char *) data->tramp.getParameter);		if (data->tramp.processReplacing)			DisposePtr((char *) data->tramp.processReplacing);		if (data->tramp.audioMaster)			DisposePtr((char *) data->tramp.audioMaster);				DisposePtr((char *) data);	}		return result;}/***	main entry of the bridge*/AEffect *main(audioMasterCallback audioMaster){	AEffect		*effect;	priv_data	*data;		/* link module and get pointer to vst_main() */	if (!vst_main && !(vst_main = get_vst_main()))		return NULL;		/* make new private instance data */	data	= (priv_data *) NewPtr(sizeof(priv_data));	if (!data)		return NULL;		/* plugin -> host trampoline */	data->tramp.audioMaster	= MachOForCFM(audioMaster);	/* get AEffect */	effect	= vst_main(data->tramp.audioMaster);	if (!effect)	{		if (data->tramp.audioMaster)			DisposePtr((char *) data->tramp.audioMaster);		DisposePtr((char *) data);		return NULL;	}		/* host -> plugin trampolines */	data->tramp.dispatcher			= CFMForMachO(effect->dispatcher);	data->tramp.process				= CFMForMachO(effect->process);	data->tramp.setParameter		= CFMForMachO(effect->setParameter);	data->tramp.getParameter		= CFMForMachO(effect->getParameter);	data->tramp.processReplacing	= CFMForMachO(effect->processReplacing);		/* transition vector of dispatcher pre-process routine */	data->pre_dispatcher			= *((TVec *) fx_dispatcher);				/* priv_data has transition vector at the beginning and it makes it work	** like CFM function pointer to fx_dispatcher().	** so it is used as a function pointer and private storage at the same time */	effect->dispatcher				= (void *) data;	/* substitute pointers to Mach-O functions with CFM trampolines. */	effect->process					= data->tramp.process;	effect->setParameter			= data->tramp.setParameter;	effect->getParameter			= data->tramp.getParameter;	effect->processReplacing		= data->tramp.processReplacing;		return effect;}#pragma mark -/* begin cuts from <mach-o/dyld.h> */#ifndef _MACH_O_DYLD_H_#ifndef ENUM_DYLD_BOOL#define ENUM_DYLD_BOOL#undef FALSE#undef TRUE#if !defined(__cplusplus) && !defined(__ALTIVEC__) && !defined(DYLD_BOOL)#define DYLD_BOOL bool#endifenum DYLD_BOOL {    FALSE,    TRUE};#endif /* ENUM_DYLD_BOOL */typedef enum {    NSObjectFileImageFailure, /* for this a message is printed on stderr */    NSObjectFileImageSuccess,    NSObjectFileImageInappropriateFile,    NSObjectFileImageArch,    NSObjectFileImageFormat, /* for this a message is printed on stderr */    NSObjectFileImageAccess} NSObjectFileImageReturnCode;typedef void * NSObjectFileImage;typedef void * NSModule;#define NSLINKMODULE_OPTION_NONE		0x0#define NSLINKMODULE_OPTION_BINDNOW		0x1#define NSLINKMODULE_OPTION_PRIVATE		0x2#define NSLINKMODULE_OPTION_RETURN_ON_ERROR	0x4typedef void * NSSymbol;#endif /*_MACH_O_DYLD_H_*//* end cuts from <mach-o/dyld.h> */static void *get_vst_main(void){	short				refNum;	FCBPBRec			pb;	Str31				name;	FSSpec				spec;	FSRef				ref;		char				path[PATH_MAX];	CFStringRef			stringRef;	CFURLRef			urlRef;	CFBundleRef			sysBundleRef = NULL;	NSObjectFileImage	objectFileImage;	void				*result = NULL;		/* dyld function pointers */	NSObjectFileImageReturnCode	(*NSCreateObjectFileImageFromFile)				(const char *pathName, NSObjectFileImage *objectFileImage)	= NULL;	enum DYLD_BOOL (*NSDestroyObjectFileImage)(NSObjectFileImage objectFileImage) = NULL;	NSModule (*NSLinkModule)(NSObjectFileImage objectFileImage, const char *moduleName,    			unsigned long options) = NULL;	NSSymbol (*NSLookupSymbolInModule)(NSModule module, const char *symbolName) = NULL;	void 	*(*NSAddressOfSymbol)(NSSymbol symbol) = NULL;			/* find out our file path */	refNum	= CurResFile();	if (refNum == -1)		return NULL;			pb.ioNamePtr	= name;	pb.ioRefNum		= refNum;	pb.ioFCBIndx	= 0;			if (	PBGetFCBInfoSync(&pb)		||	FSMakeFSSpec(pb.ioFCBVRefNum, pb.ioFCBParID, name, &spec)		||	FSpMakeFSRef(&spec, &ref)		||	FSRefMakePath(&ref, (UInt8 *) path, PATH_MAX))	{		return NULL;	}	/* get reference to the system framework */	stringRef	= CFStringCreateWithCString(NULL, "/System/Library/Frameworks/System.framework",						CFStringGetSystemEncoding());	if (stringRef)	{		urlRef	= CFURLCreateWithFileSystemPath(NULL, stringRef, kCFURLPOSIXPathStyle, 0);		if (urlRef)		{			sysBundleRef	= CFBundleCreate(NULL, urlRef);						CFRelease(urlRef);		}		CFRelease(stringRef);	}	if (!sysBundleRef)		return NULL;		/* get NSModule API function pointers */	NSCreateObjectFileImageFromFile =		CFBundleGetFunctionPointerForName(sysBundleRef, CFSTR("NSCreateObjectFileImageFromFile"));		NSDestroyObjectFileImage =		CFBundleGetFunctionPointerForName(sysBundleRef, CFSTR("NSDestroyObjectFileImage"));	NSLinkModule =		CFBundleGetFunctionPointerForName(sysBundleRef, CFSTR("NSLinkModule"));	NSLookupSymbolInModule =		CFBundleGetFunctionPointerForName(sysBundleRef, CFSTR("NSLookupSymbolInModule"));	NSAddressOfSymbol =		CFBundleGetFunctionPointerForName(sysBundleRef, CFSTR("NSAddressOfSymbol"));	/* try to create an object file image from our path */	if (NSCreateObjectFileImageFromFile(path, &objectFileImage) == NSObjectFileImageSuccess)	{		NSSymbol	symbol;		NSModule	module = NSLinkModule(objectFileImage, path, NSLINKMODULE_OPTION_PRIVATE);				if (module)		{			/* get address of the vst_main function */			symbol = NSLookupSymbolInModule(module, "_vst_main");			if (symbol)				result	= CFMForMachO(NSAddressOfSymbol(symbol));		}		NSDestroyObjectFileImage(objectFileImage);	}	CFRelease(sysBundleRef);	return result;}/***	Runtime support*//* CFM to Mach-O/Mach-O to CFM trampolines */static void *MachOForCFM(void *cfmfp){	static const UInt32 CFMTemplate[6] = {0x3D800000, 0x618C0000, 0x800C0000,										0x804C0004, 0x7C0903A6, 0x4E800420};	UInt32	*fp	= NULL;	if (cfmfp)	{		fp = (UInt32*)NewPtr(sizeof(CFMTemplate));		fp[0]	= CFMTemplate[0] | ((UInt32)cfmfp >> 16);		fp[1]	= CFMTemplate[1] | ((UInt32)cfmfp & 0xFFFF);		fp[2]	= CFMTemplate[2];		fp[3]	= CFMTemplate[3];		fp[4]	= CFMTemplate[4];		fp[5]	= CFMTemplate[5];		MakeDataExecutable(fp, sizeof(CFMTemplate));	}      	return(fp);}static void *CFMForMachO(void *machofp){	void	*fp	= NULL;	if (machofp)	{		fp	= NewPtr(8);		((void **)fp)[0] = machofp;		((void **)fp)[1] = fp;	}	return fp;}#if __MWERKS__/* MWerks linker needs this *///	__ptr_glue		-	glue for function calls through pointers////	Call the function whose 2-word TVector address is in R12.//asm void __ptr_glue(void){	smclass	GL	lwz		r0,0(r12)	stw		RTOC,20(SP)	mtctr	r0	lwz		RTOC,4(r12)	bctr}#endif /*__MWERKS__*/